static KSPIN_LOCK xenbus_dpc_lock;
static PIO_WORKITEM xenbus_watch_work_item;
uint32_t xenbus_watch_work_scheduled;

static KEVENT xb_event;

void
XenbusDpcRoutine(
	IN PKDPC Dpc,
	IN PVOID DpcContext,
	IN PVOID RegisteredContext,
	IN PVOID DeviceExtension)
{
	XEN_LOCK_HANDLE lh;

	DPR_WAIT(("XenbusDpcRoutine: cpu %x IN\n", KeGetCurrentProcessorNumber()));
	XenAcquireSpinLock(&xenbus_dpc_lock, &lh);
	XENBUS_SET_FLAG(xenbus_locks, X_DPC);
	xb_read_msg();
	XENBUS_CLEAR_FLAG(rtrace, EVTCHN_F);
	DPR_WAIT(("XenbusDpcRoutine: signaling xb_event\n"));
	KeSetEvent(&xb_event, 0, FALSE);
	if (!IsListEmpty(&watch_events)) {
		if (!xenbus_watch_work_scheduled) {
			xenbus_watch_work_scheduled = 1;
			if ((xenbus_watch_work_item =
					IoAllocateWorkItem((PDEVICE_OBJECT)DpcContext)) != NULL) {
				DPR_WAIT(("XenbusDpcRoutine: IoQueueWorkItem\n"));
				IoQueueWorkItem(xenbus_watch_work_item,
					(void (*)(PDEVICE_OBJECT, void *))xenbus_watch_work,
					DelayedWorkQueue, xenbus_watch_work_item);
			}
		}
	}
	XENBUS_CLEAR_FLAG(xenbus_locks, X_DPC);
	XenReleaseSpinLock(&xenbus_dpc_lock, lh);
	DPR_WAIT(("XenbusDpcRoutine: cpu %x OUT\n", KeGetCurrentProcessorNumber()));
}
